/*
我们的屏幕大都是由一个一个像素点构成的。随着各个像素点亮度，色彩等不同，屏幕上就可以显示各种不同的图案。
现在有一个屏幕有些奇怪，当某一个像素点亮了以后，它周边的8个点（当这个点在屏幕的边上或角上时，这个数量是
不一样的）都会亮。当然后亮的这8个点是因为这个中心点才亮的，它们不再会导致它们各自周围的点再亮了（否则一
个点亮了，整个屏幕就都亮了）。我们把前一种像素点叫主动亮的点。如图所示，如果那个红色的点为主动亮的点，则
红框内其他8个点则会因为这个主动亮的点也亮起来，但红框外边的点不会。

如果规定屏幕的左上角的坐标为（1，1），它的右边的点坐标依次为（1，2），（1，3）等等，它的下边的点坐标依次为（2，1），（3，1）等等。其他点坐标也依此类推。

现在请你写一段程序来计算一下在某种情况下这个屏幕共亮了多少个像素点。

输入格式:
第一行为三个用空格分隔的整数m,n,c(0<m,n,c<10)，依次代表屏幕像素行数，列数以及主动亮的像素点的个数。后边共c行，每行均为两个用空格分隔的整数，依次代表c个主动点亮的点的行坐标和列坐标。

测试用例保证输入合法且没有重复的主动亮的点。

输出格式:
所有亮了的像素点个数（包括主动亮的点）。

输入样例:
4 6 2
2 2
4 2
输出样例:
12
*/

#include<stdio.h>

int main()
{
    int m,n,c,i,j,k,x,y,count;
    int matrix[11][11]={0};
    
    scanf("%d%d%d",&m,&n,&c);
    
    for(i=1;i<=c;i++){
        scanf("%d%d",&x,&y);
        for(j=-1;j<=1;j++){   //两层循环控制对应坐标的像素点亮起
            for(k=-1;k<=1;k++){   //注意最左上角的坐标是（1，1）而不是（0，0）
                matrix[x+j][y+k]=1;//是赋值为1，而不是进行计数，这样可避免重复亮起所造成的问题
            }
        }
    }
    
    for(i=1;i<=m;i++){      //注意行从1到m，列从1到n遍历数组，最外面那层直接不要
        for(j=1;j<=n;j++){
            if(matrix[i][j]==1)
                count++;
        }
    }
    
    printf("%d\n",count);
    
    return 0;
}

/*心得体会：

坐标从（1，1）开始是个坑点，二重for循环把最外层去掉；

先给二维数组元素进行赋值而不是直接计数，解决重复亮起如何统计的问题*/
